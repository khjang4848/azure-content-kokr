<properties
    pageTitle="Azure 프리미엄 저장소: 성능을 위한 설계 | Microsoft Azure"
    description="Azure 프리미엄 저장소를 사용하여 고성능 응용 프로그램을 설계합니다. 프리미엄 저장소는 Azure 가상 컴퓨터에서 실행되는 I/O 사용량이 많은 작업에 대해 대기 시간이 짧은 고성능 디스크 지원을 제공합니다."
    services="storage"
    documentationCenter="na"
    authors="aungoo-msft"
    manager=""
	editor="tysonn" />

<tags
    ms.service="storage"
    ms.workload="storage"
    ms.tgt_pltfrm="na"
    ms.devlang="na"
    ms.topic="article"
    ms.date="09/19/2016"
    ms.author="aungoo-msft"/>

# Azure 프리미엄 저장소: 고성능을 위한 설계

## 개요  
이 문서는 Azure 프리미엄 저장소를 사용하여 고성능 응용 프로그램을 구축하기 위한 지침을 제공합니다. 응용 프로그램에서 사용되는 기술에 적용 가능한 성능 모범 사례가 결합된 이 문서에 제공된 지침을 사용할 수 있습니다. 지침을 설명하기 위해 이 문서 전체에서 한 예로 프리미엄 저장소에서 실행되는 SQL Server를 사용했습니다.

이 문서에서는 저장소 계층에 대한 성능 시나리오를 해결하지만 사용자는 응용 프로그램 계층을 최적화해야 합니다. 예를 들어 Azure 프리미엄 저장소에 SharePoint 팜을 호스팅하는 경우 데이터베이스 서버를 최적화하기 위해 이 문서에서 SQL Server 예제를 사용할 수 있습니다. 또한 최적의 성능을 얻기 위해 SharePoint 팜의 웹 서버 및 응용 프로그램 서버를 최적화합니다.

이 문서에서는 Azure 프리미엄 저장소에서 응용 프로그램 성능을 최적화하는 방법에 대한 다음과 같은 일반적인 질문에 대답합니다.

-   응용 프로그램 성능을 측정하는 방법은 무엇입니까?
-   예상되는 고성능이 표시되지 않는 이유는 무엇입니까?
-   프리미엄 저장소에서 응용 프로그램 성능에 영향을 주는 요인은 무엇입니까?
-   이러한 요소가 프리미엄 저장소의 응용 프로그램 성능에 주는 영향은 무엇입니까?
-   IOPS, 대역폭 및 대기 시간을 최적화하는 방법은 무엇입니까?

프리미엄 저장소에서 실행되는 작업은 성능이 매우 중요하므로 특별히 프리미엄 저장소에 대한 지침을 제공합니다. 적절한 예제를 제공합니다. 표준 저장소 디스크가 있는 IaaS VM에서 실행되는 응용 프로그램에 이러한 지침 중 일부를 적용할 수도 있습니다.

시작하기 전에 프리미엄 저장소를 처음 사용하는 경우 먼저 [프리미엄 저장소: Azure 가상 컴퓨터 작업을 위한 고성능 저장소](storage-premium-storage.md) 문서 및 [Azure 프리미엄 저장소 확장성 및 성능 목표](storage-scalability-targets.md#premium-storage-accounts)를 읽어 보세요.

## 응용 프로그램 성과 지표  
응용 프로그램이 사용자 요청을 얼마나 빨리 처리하는지, 응용 프로그램이 요청 당 얼마나 많은 데이터를 처리하는지, 응용 프로그램이 특정 기간 동안 얼마나 많은 요청을 처리하는지, 사용자가 요청을 제출한 후 응답을 받기까지 얼마나 오래 기다려야 하는지와 같은 성과 지표를 사용하여 응용 프로그램이 잘 수행하는지 여부를 평가합니다. 이러한 성과 지표에 대한 기술 용어는 IOPS, 처리량 또는 대역폭 및 대기 시간입니다.

이 섹션에서는 프리미엄 저장소의 컨텍스트에서 일반적인 성과 지표를 설명합니다. 다음 섹션, 응용 프로그램 요구 사항 수집에서는 응용 프로그램에 대한 이러한 성과 지표를 측정하는 방법을 배웁니다. 응용 프로그램 성능 최적화의 뒷부분에서 이러한 성과 지표 및 최적화를 위한 권장 사항에 영향을 주는 요소에 대해 배웁니다.

## IOPS  
IOPS는 응용 프로그램에서 저장소 디스크에 1초 동안 보내는 요청 수입니다. 입력/출력 작업은 읽기나 쓰기, 순차 또는 임의가 될 수 있습니다. 온라인 소매 웹 사이트와 같은 OLTP 응용 프로그램은 많은 동시 사용자 요청을 즉시 처리해야 합니다. 사용자 요청은 응용 프로그램에서 신속하게 처리해야 할 삽입 및 업데이트 집약적 데이터베이스 트랜잭션입니다. 따라서 OLTP 응용 프로그램에는 매우 높은 IOPS가 필요합니다. 이러한 응용 프로그램에서는 수백만 개의 작고 임의의 IO 요청을 처리합니다. 이러한 응용 프로그램을 사용하는 경우 IOPS에 대해 최적화하기 위해 응용 프로그램 인프라를 설계해야 합니다. 이후 섹션 *응용 프로그램 성능 최적화*에서 높은 IOPS를 얻기 위해는 고려해야 하는 모든 요소를 자세히 설명합니다.

높은 확장성의 VM에 프리미엄 저장소에 디스크를 연결하는 경우 Azure는 디스크 사양에 따라 보장된 IOPS 수에 대해 프로비전합니다. 예를 들어 P30 디스크는 5000 IOPS를 프로비전합니다. 각 높은 확장성의 VM 크기에는 유지할 수 있는 특정 IOPS 제한이 있습니다. 예를 들어 표준 GS5 VM에는 80,000 IOPS 제한이 있습니다.

## 처리량  
처리량 또는 대역폭은 응용 프로그램이 지정된 간격의 저장소 디스크에 보내는 데이터의 양입니다. 응용 프로그램이 대량 IO 단위 크기를 사용하여 입력/출력 작업을 수행하는 경우 높은 처리량이 필요합니다. 데이터 웨어하우스 응용 프로그램은 한 번에 많은 양의 데이터에 액세스하고 일반적으로 대량 작업을 수행하는 스캔 집약적인 작업을 실행하는 경향이 있습니다. 즉, 이러한 응용 프로그램에는 더 높은 처리량이 필요합니다. 이러한 응용 프로그램을 사용하는 경우 처리량에 대해 최적화하기 위해 해당 인프라를 설계해야 합니다. 다음 섹션에서 이를 달성하기 위해 조정해야 하는 요인을 자세히 설명합니다.

프리미엄 저장소 디스크를 높은 확장성의 VM에 연결하는 경우 Azure는 해당 디스크 사양에 따라 처리량을 프로비전합니다. 예를 들어 P30 디스크는 초당 200MB 디스크 처리량을 프로비전합니다. 높은 확장성의 VM 크기마다 유지할 수 있는 특정 처리량 제한이 있습니다. 예를 들어 표준 GS5 VM에는 초당 2,000MB의 최대 처리량이 있습니다.

아래 수식에 표시된 것처럼 처리량과 IOPS 간에 관계가 있습니다.

![](media/storage-premium-storage-performance/image1.png)

따라서 응용 프로그램에 필요한 최적의 처리량 및 IOPS 값을 결정하는 것이 중요합니다. 하나를 최적화하려고 할 때 다른 하나도 영향을 받습니다. 이후 섹션 *응용 프로그램 성능 최적화*에서 IOPS 및 처리량 최적화에 대한 자세한 정보에 대해 설명합니다.

## 대기 시간  
대기 시간은 응용 프로그램이 단일 요청을 수신하고 이를 저장소 디스크에 보내고 클라이언트에 응답을 보내는데 걸리는 시간입니다. 이는 IOPS 및 처리량 외에도 응용 프로그램의 성능에 대한 중요한 측정입니다. 프리미엄 저장소 디스크의 대기 시간은 요청에 대한 정보를 검색하고 응용 프로그램에게 다시 전달하는데 걸리는 시간입니다. 프리미엄 저장소는 일관된 낮은 대기 시간을 제공합니다. 프리미엄 저장소 디스크에 읽기 전용 호스트 캐싱을 사용하는 경우 훨씬 더 낮은 읽기 대기 시간을 얻을 수 있습니다. *응용 프로그램 성능 최적화*의 이후 섹션에서 디스크 캐싱에 대해 자세히 설명합니다.

높은 IOPS 및 처리량을 얻기 위해 응용 프로그램을 최적화하는 경우 응용 프로그램의 대기 시간에 영향을 줍니다. 응용 프로그램 성능 튜닝 후 예기치 않은 대기 시간 동작을 방지하도록 항상 응용 프로그램의 대기 시간을 평가합니다.

## 응용 프로그램 성능 요구 사항 수집  
Azure 프리미엄 저장소에서 실행되는 고성능 응용 프로그램을 설계하는 첫 번째 단계는 응용 프로그램의 성능 요구 사항을 이해하는 것입니다. 성능 요구 사항을 수집한 후에 최적의 성능을 얻을 수 있도록 응용 프로그램을 최적화할 수 있습니다.

이전 섹션에서 일반적인 성과 지표, IOPS, 처리량 및 대기 시간을 설명했습니다. 원하는 사용자 환경을 제공하기 위해 어떤 성과 지표가 응용 프로그램에 중요한지 식별해야 합니다. 예를 들어 초당 수백만 개의 트랜잭션을 처리하는 OLTP 응용 프로그램에는 높은 IOPS가 가장 중요합니다. 반면 초당 많은 양의 데이터를 처리하는 데이터 웨어하우스 응용 프로그램에는 높은 처리량이 중요합니다. 라이브 비디오 스트리밍 웹 사이트와 같은 실시간 응용 프로그램에는 매우 짧은 대기 시간이 중요합니다.

다음으로 해당 수명 주기 동안 응용 프로그램의 최대 성능 요구 사항을 측정합니다. 시작으로 아래 샘플 검사 목록을 사용합니다. 일반, 최고 및 작업 시간 외 작업 기간 동안 최대 성능 요구 사항을 기록합니다. 모든 작업 수준에 대한 요구 사항을 파악하여 응용 프로그램의 전반적인 성능 요구 사항을 확인할 수 있습니다. 예를 들어 전자 상거래 웹 사이트의 일반 작업은 1년 중 대부분 동안 제공하는 트랜잭션이 됩니다. 웹 사이트의 최대 작업은 축제 시즌 또는 특별 판매 이벤트 동안 제공하는 트랜잭션이 됩니다. 최대 작업은 일반적으로 제한된 기간에 대해 숙련되지만 응용 프로그램이 두 번 이상 해당 일반 작업을 확장해야 할 수 있습니다. 50 백분위수, 90 백분위수 및 99 백분위수 요구 사항에 알아봅니다. 이렇게 하면 성능 요구 사항에서 모든 이상값을 필터링하고 올바른 값에 대한 최적화에 노력을 집중할 수 있습니다.

**응용 프로그램 성능 요구 사항 검사 목록**

| **성능 요구 사항** | **50 백분위수** | **90 백분위수** | **99 백분위수** |
|---|---|---|---|
| 최대 초당 트랜잭션 수 | | | |
| % 읽기 작업 | | | |
| % 쓰기 작업 | | | |
| % 임의 작업 | | | |
| % 순차적 작업 | | | |
| IO 요청 크기 | | | |
| 평균 처리량 | | | |
| 최대 처리량 | | | |
| 최소 대기 시간 | | | |
| 평균 대기 시간 | | | |
| 최대 CPU | | | |
| 평균 CPU | | | |
| 최대 메모리 | | | |
| 평균 메모리 | | | |
| 큐 크기 | | | |

>**중요:** 응용 프로그램의 예상된 향후 성장에 따라 이러한 숫자를 확장하는 것이 좋습니다. 나중에 성능 향상을 위한 인프라를 변경하기가 더 어려울 수 있으므로 사전 확장을 계획하는 것이 좋습니다.

기존 응용 프로그램이 있고 프리미엄 저장소로 이동하려는 경우 먼저 기존 응용 프로그램에 대해 위의 검사 목록을 빌드합니다. 그런 다음 프리미엄 저장소에 있는 응용 프로그램의 프로토타입을 빌드하고 이 문서의 이후 섹션의 *응용 프로그램 성능 최적화*에 설명된 지침에 따라 응용 프로그램을 설계합니다. 다음 섹션에서는 성능 측정값을 수집하는데 사용할 수 있는 도구를 설명합니다.

프로토타입에 대한 기존 응용 프로그램과 비슷한 검사 목록을 만듭니다. 벤치마킹 도구를 사용하여 작업을 시뮬레이션하고 프로토타입 응용 프로그램의 성능을 측정할 수 있습니다. 자세한 내용은 [벤치마킹](#benchmarking)의 섹션을 참조하세요. 이렇게 하여 프리미엄 저장소가 응용 프로그램 성능 요구 사항에 일치하거나 능가할 수 있는지 여부를 결정할 수 있습니다. 그런 다음 프로덕션 응용 프로그램에 대해 동일한 지침을 구현할 수 있습니다.

### 응용 프로그램 성능 요구 사항을 측정하기 위한 카운터  
응용 프로그램의 성능 요구 사항을 측정하는 가장 좋은 방법은 서버의 운영 체제에서 제공하는 성능 모니터링 도구를 사용하는 것입니다. Windows용 PerfMon 및 Linux용 iostat를 사용할 수 있습니다. 이러한 도구는 위의 섹션에서 설명된 각 측정에 해당하는 카운터를 캡처합니다. 응용 프로그램이 일반, 최고 및 작업 시간 외 작업을 실행하는 경우 이러한 카운터의 값을 캡처해야 합니다.

PerfMon 카운터는 프로세서, 메모리, 각 논리 디스크 및 서버의 실제 디스크에 대해 사용할 수 있습니다. VM에서 프리미엄 저장소 디스크를 사용하는 경우 실제 디스크 카운터는 각 프리미엄 저장소 디스크에 대한 것이며 논리 디스크 카운터는 프리미엄 저장소 디스크에 생성된 각 볼륨에 대한 것입니다. 응용 프로그램 작업을 호스팅하는 디스크에 대한 값을 캡처해야 합니다. 논리 및 실제 디스크 간에 일대일 매핑이 있는 경우 실제 디스크 카운터를 참조할 수 있으며 그렇지 않은 경우 논리 디스크 카운터를 참조합니다. Linux에서 iostat 명령은 CPU 및 디스크 사용률 보고서를 생성합니다. 디스크 사용률 보고서는 물리적 장치 또는 파티션당 통계를 제공합니다. 별도 디스크에 해당 데이터와 로그가 있는 데이터베이스 서버가 있는 경우 두 디스크에 대한 이 데이터를 수집합니다. 아래 표에서 디스크, 프로세서 및 메모리에 대한 카운터를 설명합니다.

| 카운터 | 설명 | PerfMon | Iostat |
|---|---|---|---|
| **초당 IOPS 또는 트랜잭션** | 저장소 디스크에 발급된 초당 I/O 요청 수입니다. | 디스크 읽기/초 <br> 디스크 쓰기/초 | tps <br> r/s <br> w/s |
| **디스크 읽기 및 쓰기** | 디스크에서 수행되는 읽기 및 쓰기 작업의 %입니다. | % 디스크 읽기 시간 <br> % 디스크 쓰기 시간 | r/s <br> w/s |
| **처리량** | 초당 디스크에서 읽거나 디스크에 쓴 데이터 양입니다. | 디스크 읽기 바이트/초 <br> 디스크 쓰기 바이트/초 | kB\_read/s <br> kB\_wrtn/s |
| **대기 시간** | 디스크 IO 요청을 완료하는 총 시간입니다. | 평균 디스크 초/읽기 <br> 평균 디스크 초/쓰기 | await <br> svctm |
| **IO 크기** | I/O의 요청의 크기는 저장소 디스크에 발급합니다. | 평균 디스크 바이트/읽기 <br> 평균 디스크 바이트/쓰기 | avgrq-sz |
| **큐 크기** | 저장소 디스크에서 읽거나 저장소 디스크에 쓰도록 대기 중인 미해결 I/O 요청의 수입니다. | 현재 디스크 큐 길이 | avgqu-sz |
| **최대 메모리** | 응용 프로그램을 원활하게 실행하는데 필요한 메모리의 양 | % 사용 중인 커밋된 바이트 | vmstat 사용 |
| **최대 CPU** | 응용 프로그램을 원활하게 실행하는데 필요한 CPU 양 | % 프로세서 시간 | %util |

[iostat](http://linuxcommand.org/man_pages/iostat1.html) 및 [PerfMon](https://msdn.microsoft.com/library/aa645516.aspx)에 대해 자세히 알아봅니다.


## 응용 프로그램 성능 최적화  
프리미엄 저장소에서 실행 중인 응용 프로그램의 성능에 영향을 주는 주요 요인은 IO 요청의 특성, VM 크기, 디스크 크기, 디스크 수, 디스크 캐싱, 멀티 스레드 및 큐 크기입니다. 이러한 요소 중 일부는 시스템에서 제공하는 노브를 사용하여 제어할 수 있습니다. 대부분의 응용 프로그램은 IO 크기 및 큐 크기를 직접 변경할 수 있는 옵션을 제공하지 못할 수도 있습니다. 예를 들어 SQL Server를 사용하는 경우 IO 크기 및 큐 길이를 선택할 수 없습니다. SQL Server에서는 최적의 성능을 얻기 위해 최적의 IO 크기 및 큐 크기 값을 선택합니다. 성능 요구 사항에 맞게 적절한 리소스를 프로비전할 수 있도록 두 요소 형식이 응용 프로그램 성능에 미치는 영향을 이해하는 것이 중요합니다.

이 섹션 전체에서 응용 프로그램 성능을 최적화하기 위해 필요한 정도를 식별하도록 만든 응용 프로그램 요구 사항 검사 목록을 참조하세요. 그에 따라 이 섹션에서 조정할 요인을 확인할 수 있습니다. 각 요인이 응용 프로그램 성능에 미치는 영향을 감시하려면 응용 프로그램 설치에서 벤치마킹 도구를 실행합니다. Windows 및 Linux VM에서 일반적인 벤치마킹 도구를 실행하는 단계에 대한 문서의 마지막에 있는 [벤치마킹](#Benchmarking) 섹션을 참조하세요.

### 한 눈에 IOPS, 처리량 및 대기 시간 최적화  
다음 표에서 모든 성능 요소 및 IOPS, 처리량 및 대기 시간을 최적화하는 단계를 요약합니다. 이 요약에 이어지는 섹션에서는 각 요인을 더 자세히 설명합니다.

| | **IOPS** | **처리량** | **대기 시간** |
|---|---|---|---|
| **예제 시나리오** | 초당 비율로 매우 높은 트랜잭션이 필요한 엔터프라이즈 OLTP 응용 프로그램입니다. | 다량의 데이터를 처리하는 엔터프라이즈 데이터 웨어하우징 응용 프로그램입니다. | 온라인 게임과 같은 사용자 요청에 대한 즉각적인 응답이 필요한 거의 실시간 응용 프로그램입니다. |
| 성능 요인 | | | |
| **IO 크기** | 작은 크기의 IO는 더 높은 IOPS를 생성합니다. | 큰 IO 크기는 더 높은 처리량을 생성합니다. | |
| **VM 크기** | 응용 프로그램 요구 사항보다 큰 IOPS를 제공하는 VM 크기를 사용합니다. VM 크기 및 IOPS 한계는 여기를 참조하세요. | 응용 프로그램 요구 사항보다 큰 처리량 한계가 있는 VM 크기를 사용합니다. VM 크기 및 처리량 한계는 여기를 참조하세요. | 응용 프로그램 요구 사항보다 큰 규모 제한을 제공하는 VM 크기를 사용합니다. VM 크기 및 한계는 여기를 참조하세요. |
| **디스크 크기** | 응용 프로그램 요구 사항보다 큰 IOPS를 제공하는 디스크 크기를 사용합니다. 디스크 크기 및 IOPS 한계는 여기를 참조하세요. | 응용 프로그램 요구 사항보다 큰 처리량 한계가 있는 디스크 크기를 사용합니다. 디스크 크기 및 처리량 한계는 여기를 참조하세요. | 응용 프로그램 요구 사항보다 큰 규모 제한을 제공하는 디스크 크기를 사용합니다. 디스크 크기 및 한계는 여기를 참조하세요. |
| **VM 및 디스크 규모 제한** | 선택한 VM 크기의 IOPS 제한은 연결된 프리미엄 저장소 디스크에 의해 발생하는 총 IOPS보다 커야 합니다. | 선택한 VM 크기의 처리량 제한은 연결된 프리미엄 저장소 디스크에 의한 총 처리량보다 커야 합니다. | 선택한 VM 크기의 규모 제한은 연결된 프리미엄 저장소 디스크의 총 규모 제한보다 커야 합니다. |
| **디스크 캐싱** | 더 많은 읽기 IOPS를 얻기 위해 많은 읽기 작업과 함께 프리미엄 저장소 디스크의 읽기 전용 캐시를 사용합니다. | | 더 짧은 읽기 대기 시간을 얻기 위해 많은 읽기 작업과 함께 프리미엄 저장소 디스크의 ReadOnly 캐시를 사용합니다. |
| **디스크 스트라이프** | 결합된 높은 IOPS 및 처리량 한계를 얻기 위해 여러 디스크 및 디스크 스트라이프를 사용합니다. VM당 결합된 한계는 연결된 프리미엄 디스크의 결합된 제한보다 높아야 합니다. | |
| **스트라이프 크기** | OLTP 응용 프로그램에 표시된 작은 임의 IO 패턴에 대한 더 작은 스트라이프 크기입니다. 예: SQL Server OLTP 응용 프로그램에 대해 64KB의 스트라이프 크기를 사용합니다. | 데이터 웨어하우스에 응용 프로그램에 표시된 대형 순차 IO 패턴에 대한 더 큰 스트라이프 크기입니다. 예: SQL Server 데이터 웨어하우스 응용 프로그램에 대해 256KB의 스트라이프 크기를 사용합니다. | |
| **멀티 스레드** | 높은 IOPS 및 처리량을 얻도록 하는 프리미엄 저장소에 더 높은 요청 수를 밀어 넣도록 멀티 스레드를 사용합니다. 예를 들어 SQL Server에서 SQL Server에 더 많은 CPU를 할당하는 높은 MAXDOP 값을 설정합니다. | |
| **큐 크기** | 더 큰 큐 크기는 더 높은 IOPS를 생성합니다. | 더 큰 큐 크기는 더 높은 처리량을 생성합니다. | 더 작은 큐 크기는 더 짧은 대기 시간을 생성합니다. |

## IO 요청의 특성  
IO 요청은 응용 프로그램에서 수행하는 입력/출력 작업의 단위입니다. IO 요청, 임의 또는 순차, 읽기 또는 쓰기, 소형 또는 대형의 특성을 식별하면 응용 프로그램의 성능 요구 사항을 결정하는데 도움이 됩니다. 응용 프로그램 인프라를 설계할 때 올바른 결정을 내릴 수 있도록 IO 요청의 특성을 이해하는 것은 중요합니다.

IO 크기는 더 중요한 요소 중 하나입니다. IO 크기는 응용 프로그램에 의해 생성된 입력/출력 작업 요청의 크기입니다. IO 크기는 응용 프로그램에서 달성할 수 있는 성능 특히 IOPS 및 대역폭에 큰 영향을 줍니다. 다음 수식은 IOPS 간의 관계, IO 크기 및 대역폭/처리량을 보여 줍니다.![](media/storage-premium-storage-performance/image1.png)

일부 응용 프로그램은 해당 IO 크기 변경을 허용하지만 일부 응용 프로그램은 그렇지 않습니다. 예를 들어 SQL Server는 자체적으로 최적의 IO 크기를 결정하고 변경할 수 있는 노브를 사용자에게 제공하지 않습니다. 반대로 Oracle은 데이터베이스의 I/O 요청 크기를 구성할 수 있는 [DB\_BLOCK\_SIZE](https://docs.oracle.com/cd/B19306_01/server.102/b14211/iodesign.htm#i28815)라는 매개 변수를 제공합니다.

IO 크기 변경을 허용하지 않는 응용 프로그램을 사용하는 경우 이 문서의 지침을 사용하여 응용 프로그램에 가장 관련이 있는 성능 KPI를 최적화합니다. 예를 들면 다음과 같습니다.

-   OLTP 응용 프로그램에서는 수백만 개의 작고 임의적인 IO 요청을 생성합니다. 이러한 유형의 IO 요청을 처리하려면 높은 IOPS를 얻도록 응용 프로그램 인프라를 설계해야 합니다.
-   데이터 웨어하우징 응용 프로그램은 크고 순차적인 IO 요청을 생성합니다. 이러한 형식의 IO 요청을 처리하려면 높은 대역폭 또는 처리량을 얻도록 응용 프로그램 인프라를 설계해야 합니다.

IO 크기를 변경할 수 있는 응용 프로그램을 사용하는 경우 다른 성능 지침 외에도 IO 크기에 대한 이 규칙을 사용합니다.

-   작은 크기의 IO는 더 높은 IOPS를 얻습니다. 예를 들어 OLTP 응용 프로그램의 경우 8KB입니다.
-   더 높은 대역폭/처리량을 얻기 위한 더 큰 크기의 IO입니다. 예를 들어 데이터 웨어하우스 응용 프로그램의 경우 1024KB입니다.

응용 프로그램에 대한 IOPS 및 처리량/대역폭을 계산하는 방법에 대한 예입니다. P30 디스크를 사용하여 응용 프로그램을 고려합니다. 최대 IOPS 및 처리량/대역폭 P30 디스크는 각각 초당 5000 IOPS와 200MB를 얻을 수 있습니다. 이제 응용 프로그램이 P30 디스크에서 최대 IOPS가 필요하고 8KB와 같은 작은 IO 크기를 사용하는 경우 얻을 수 결과 대역폭은 초당 40MB입니다. 그러나 응용 프로그램이 P30 디스크에서 최대 처리량/대역폭이 필요하고 1024KB와 같은 큰 IO 크기를 사용하는 경우 결과 IOPS는 200 IOPS 미만입니다. 따라서 두 응용 프로그램의 IOPS 및 처리량/대역폭 요구 사항이 충족되도록 IO 크기를 조정합니다. 아래 표에서 P30 디스크에 대한 다양한 IO 크기 및 해당 IOPS와 처리량을 요약합니다.

| **응용 프로그램 요구 사항** | **I/O 크기** | **IOPS** | **처리량/대역폭** |
|-----------------------------|--------------|----------|--------------------------|
| 최대 IOPS | 8KB | 5, 000 | 초당 40MB |
| 최대 처리량 | 1024KB | 200 | 초당 200MB |
| 최대 처리량 + 높은 IOPS | 64KB | 3,200 | 초당 200MB |
| 최대 IOPS + 높은 처리량 | 32KB | 5, 000 | 초당 160MB |

단일 프리미엄 저장소 디스크의 최대값보다 높은 IOPS 및 대역폭을 얻으려면 함께 스트라이프된 여러 프리미엄 디스크를 사용합니다. 예를 들어 10000 IOPS의 결합된 IOPS 또는 초당 400MB의 결합된 처리량을 얻으려면 두 P30 디스크를 스트라이프합니다. 다음 섹션에서 설명한 것과 같이 결합된 디스크 IOPS 및 처리량을 지원하는 VM 크기를 사용해야 합니다.

>**참고:** IOPS 또는 처리량을 늘리면 다른 쪽 또한 증가하므로 둘 중 하나를 늘리는 경우 디스크 또는 VM의 처리량 또는 IOPS 제한에 도달하지 않도록 합니다.

응용 프로그램 성능에 미치는 IO 크기의 영향을 감시하려면 VM 및 디스크에서 벤치마킹 도구를 실행할 수 있습니다. 여러 테스트 실행을 만들고 각 실행에 대한 다른 IO 크기를 사용하여 어떤 영향이 있는지 확인합니다. 자세한 내용은 이 문서의 마지막 부분에 있는 [벤치마킹](#Benchmarking) 섹션을 참조하세요.

## 높은 확장성의 VM 크기  
응용 프로그램 설계를 시작할 때 실행할 첫 번째 작업 중 하나는 응용 프로그램을 호스팅할 VM을 선택하는 것입니다. 프리미엄 저장소는 높은 계산 능력 및 높은 로컬 디스크 I/O 성능이 필요한 응용 프로그램을 실행할 수 있는 높은 확장성의 VM 크기와 함께 제공됩니다. 이러한 VM은 로컬 디스크에 대한 빠른 프로세서, 더 높은 메모리-코어 비율 및 SSD(반도체 드라이브)를 제공합니다. 프리미엄 저장소를 지원하는 높은 확장성의 VM의 예는 DS, DSv2 및 GS 시리즈 VM입니다.

높은 확장성의 VM은 다양한 수의 CPU 코어, 메모리, OS 및 임시 디스크 크기와 함께 다양한 크기에서 사용할 수 있습니다. 각 VM 크기에는 또한 VM에 연결할 수 있는 데이터 디스크의 최대 수가 있습니다. 따라서 선택한 VM 크기는 응용 프로그램에 대해 사용할 수 있는 프로세스, 메모리 및 저장소 용량에 영향을 줍니다. 계산 및 저장소 비용에도 영향을 줍니다. 예를 들어 아래는 DS 시리즈, DSv2 시리즈 및 GS 시리즈에서 가장 큰 VM 크기의 사양입니다.

| VM 크기 | CPU 코어 | 메모리 | VM 디스크 크기 | 최대 데이터 디스크 | 캐시 크기 | IOPS | 대역폭 캐시 IO 제한 |
|---|---|---|---|---|---|---|---|
| Standard\_DS14 | 16 | 112GB | OS = 1023GB <br> 로컬 SSD = 224GB | 32 | 576GB | 50,000 IOPS <br> 초당 512MB | 4,000 IOPS 및 초당 33MB |
| Standard\_GS5 | 32 | 448GB | OS = 1023GB <br> 로컬 SSD = 896GB | 64 | 4224GB | 80,000 IOPS <br> 초당 2,000MB | 5,000 IOPS 및 초당 50MB |

사용 가능한 모든 Azure VM 크기의 전체 목록을 보려면 [Windows VM 크기](../virtual-machines/virtual-machines-windows-sizes.md) 또는 [Linux VM 크기](../virtual-machines/virtual-machines-linux-sizes.md)를 참조하세요. 원하는 응용 프로그램 성능 요구 사항에 충족하고 확장할 수 있는 VM 크기를 선택합니다. 이 외에도 VM 크기를 선택할 때 다음 중요한 고려 사항을 고려합니다.


*규모 제한* VM당 및 디스크당 최대 IOPS 제한은 서로 다르고 독립적입니다. 응용 프로그램이 연결된 프리미엄 디스크 뿐만 아니라 VM의 제한 내에서 IOPS를 구동하는지 확인합니다. 그렇지 않은 경우 응용 프로그램 성능에 제한이 발생합니다.

한 예로 응용 프로그램 요구 사항이 최대 4,000 IOPS라 가정합니다. 이를 위해 DS1 VM에서 P30 디스크를 프로비전합니다. P30 디스크는 최대 5,000 IOPS를 제공할 수 있습니다. 그러나 DS1 VM은 3,200 IOPS로 제한됩니다. 따라서 응용 프로그램 성능은 3,200 IOPS에서 VM 한계로 제한이 적용되고 성능이 저하됩니다. 이러한 상황을 방지하려면 응용 프로그램 요구 사항을 충족하는 VM 및 디스크 크기를 선택합니다.

*작업 비용* 대부분의 경우에서 프리미엄 저장소를 사용하는 작업의 전체 비용은 표준 저장소를 사용하는 비용보다 낮을 수 있습니다.

예를 들어 16,000 IOPS를 필요로 하는 응용 프로그램을 가정합니다. 이 성능을 달성하려면 32개의 표준 저장소 1TB 디스크를 사용하여 16,000의 최대 IOPS를 제공할 수 있는 Standard\_D14 Azure IaaS VM이 필요합니다. 각 1TB 표준 저장소 디스크는 최대 500 IOPS를 달성할 수 있습니다. 월별 이 VM의 예상된 비용은 $1,570가 됩니다. 32개의 표준 저장소 디스크의 월간 비용은 $1,638가 됩니다. 예상되는 총 월간 비용은 $3,208가 됩니다.

그러나 프리미엄 저장소에 동일한 응용 프로그램을 호스팅한 경우 더 작은 VM 크기와 적은 프리미엄 저장소 디스크가 필요하므로 전반적인 비용이 절감됩니다. Standard\_DS13 VM은 4개의 P30 디스크를 사용하여 16,000 IOPS 요구 사항을 충족할 수 있습니다. DS13 VM은 25,600의 최대 IOPS를 가지고 각 P30 디스크는 5,000의 최대 IOPS를 가집니다. 전체적으로 이 구성은 5,000 x 4 = 20,000 IOPS를 달성할 수 있습니다. 예상되는 이 VM의 월별 비용은 $1,003입니다. 4개의 P30 프리미엄 저장소 디스크의 월간 비용은 $544.34가 됩니다. 예상되는 총 월별 비용은 $1,544입니다.

다음 표에서 표준 및 프리미엄 저장소에 대한 이 시나리오의 비용 분석을 요약합니다.

| | **Standard** | **Premium** |
|---|---|---|
| **월별 VM 비용** | $1,570.58(Standard\_D14) | $1,003.66(Standard\_DS13) |
| **월별 디스크 비용** | $1,638.40(32 x 1 TB 디스크) | $544.34(4 x P30 디스크) |
| **월별 전체 비용** | $3,208.98 | $1,544.34 |

*Linux 배포판*

Azure 프리미엄 저장소를 사용하여 Windows 및 Linux를 실행하는 VM에 대해 동일한 성능 수준을 얻습니다. Linux 배포판의 여러 버전을 지원하고 [여기](../virtual-machines/virtual-machines-linux-endorsed-distros.md)에서 전체 목록을 볼 수 있습니다. 다양한 배포판은 다양한 유형의 작업에 더 적합합니다. 작업이 실행 중인 배포판에 따라 다른 수준의 성능을 확인할 수 있습니다. 응용 프로그램을 사용하여 Linux 배포판을 테스트하고 가장 잘 작동하는 것을 선택합니다.


프리미엄 저장소를 사용하여 Linux를 실행할 때 높은 성능을 보장하기 위해 필요한 드라이버에 대한 최신 업데이트를 확인합니다.

## 프리미엄 저장소 디스크 크기  
Azure 프리미엄 저장소는 현재 3개의 디스크 크기를 제공합니다. 각 디스크 크기는 IOPS, 대역폭 및 저장소에 대한 다른 규모 한도를 가집니다. 응용 프로그램 요구 사항 및 높은 확장성의 VM 크기에 따라 올바른 프리미엄 저장소 디스크 크기를 선택합니다. 아래 표에서 3개의 디스크 크기와 해당 기능을 보여 줍니다.

| **디스크 유형** | **P10** | **P20** | **P30** |
|---------------------|-------------------|-------------------|-------------------|
| 디스크 크기 | 128GiB | 512GiB | 1024GiB(1TB) |
| 디스크당 IOPS | 500 | 2300 | 5000 |
| 디스크당 처리량 | 초당 100MB | 초당 150MB | 초당 200MB |

선택하는 디스크의 수는 선택한 디스크 크기에 따라 달라집니다. 응용 프로그램 요구 사항에 맞게 P30 디스크 하나 또는 여러 P10 디스크를 사용할 수 있습니다. 선택할 때 다음에 나열된 고려 사항을 고려합니다.

*규모 제한(IOPS 및 처리량)* 각 프리미엄 디스크 크기의 IOPS 및 처리량 한계는 VM 규모 제한과 서로 다르며 독립적입니다. 디스크에서 총 IOPS 및 처리량이 선택한 VM 크기의 규모 제한 내에 있는지 확인합니다.

예를 들어 응용 프로그램 요구 사항이 최대 250MB/초의 처리량이고 단일 P30 디스크와 함께 DS4 VM을 사용하는 경우를 가정합니다. DS4 VM은 최대 256MB/초의 처리량을 제공할 수 있습니다. 그러나 단일 P30 디스크는 200MB/초의 처리량 제한이 있습니다. 따라서 디스크 제한으로 인해 응용 프로그램에 200MB/초로 제한이 적용됩니다. 이 제한을 극복하기 위해 VM에 둘 이상의 데이터 디스크를 프로비전합니다.

>**참고:** 캐시에서 제공하는 읽기는 디스크 IOPS 및 처리량에 포함되지 않으므로 디스크 제한이 없습니다. 캐시에는 VM당 별도 IOPS 및 처리량 제한이 있습니다.
>
>예를 들어 처음에 읽기 및 쓰기는 각각 60MB/초 및 40MB/초입니다. 시간이 지남에 따라 캐시는 가동 준비하고 캐시에서 더 많은 읽기를 제공합니다. 그런 다음 디스크에서 더 높은 쓰기 처리량을 얻을 수 있습니다.

*디스크 수* 응용 프로그램 요구 사항을 평가하여 필요한 디스크 수를 결정합니다. 각 VM 크기는 VM에 연결할 수 있는 디스크 수의 제한 또한 있습니다. 일반적으로 코어 수의 두 배입니다. 선택한 VM 크기가 필요한 디스크 수를 지원할 수 있는지 확인합니다.

프리미엄 저장소 디스크에는 표준 저장소 디스크에 비해 더 높은 성능 기능이 있습니다. 따라서 표준 저장소를 사용하여 Azure IaaS VM에서 응용 프로그램을 프리미엄 저장소로 마이그레이션하는 경우 응용 프로그램에 대해 동일 하거나 더 높은 성능을 얻을 수 있도록 더 적은 프리미엄 디스크가 필요할 가능성이 있습니다.

## 디스크 캐싱  
Azure 프리미엄 저장소를 활용하는 높은 확장성의 VM에는 BlobCache 라는 다중 계층 캐싱 기술이 있습니다. BlobCache는 캐싱에 대해 가상 컴퓨터 RAM 및 로컬 SSD의 조합을 사용합니다. 이 캐시는 프리미엄 저장소 영구 디스크 및 VM 로컬 디스크에 사용할 수 있습니다. 기본적으로 이 캐시 설정은 OS 디스크에 대해 읽기/쓰기로 프리미엄 저장소에서 호스팅되는 데이터 디스크에 대해 읽기 전용으로 설정됩니다. 프리미엄 저장소 디스크에서 디스크 캐싱을 사용하면 높은 확장성의 VM은 기본 디스크 성능을 초과하는 매우 높은 수준의 성능을 얻을 수 있습니다.

>[AZURE.WARNING] Azure 디스크의 캐시 설정을 변경하면 대상 디스크가 분리되었다가 다시 연결됩니다. 운영 체제 디스크인 경우 VM이 다시 시작됩니다. 디스크 캐시 설정을 변경하기 전에 이 중단의 영향을 받을 수 있는 모든 응용 프로그램/서비스를 중지합니다.

BlobCache를 작동하는 방법에 대한 자세한 내용은 내부 [Azure 프리미엄 저장소](https://azure.microsoft.com/blog/azure-premium-storage-now-generally-available-2/) 블로그 게시물을 참조하세요.

올바른 디스크 집합에 캐시를 사용하는 것이 중요합니다. 프리미엄 디스크에 디스크 캐싱을 사용하도록 설정할지 여부는 디스크가 처리될 작업 패턴에 따라 달라집니다. 다음 표에서 OS 및 데이터 디스크에 대한 기본 캐시 설정을 보여 줍니다.

| **디스크 유형** | **기본 캐시 설정** |
|---|---|
| OS 디스크 | ReadWrite |
| 데이터 디스크 | 없음 |

다음은 데이터 디스크에 대한 권장 디스크 캐시 설정입니다.

| **디스크 캐싱 설정** | **이 설정을 사용하는 시점에 대한 권장 사항** |
|---|---|
| 없음 | 쓰기 전용 및 쓰기가 많은 디스크에 대해 None으로 호스트-캐시를 구성합니다. |
| ReadOnly | 읽기 전용 및 읽기-쓰기 디스크에 대해 ReadOnly로 호스트-캐시를 구성합니다. |
| ReadWrite | 응용 프로그램이 필요할 때 영구 디스크에 캐시된 데이터 쓰기를 올바르게 처리하는 경우 ReadWrite로 호스트-캐시를 구성합니다. |

*ReadOnly* 프리미엄 저장소 데이터 디스크에 ReadOnly 캐싱을 구성하여 짧은 읽기 대기 시간을 달성하고 응용 프로그램에 대한 매우 높은 읽기 IOPS 및 처리량을 얻을 수 있습니다. 다음 두 가지 이유로 인한 것입니다.

1.  VM 메모리 및 로컬 SSD에 있는 캐시에서 수행되는 읽기는 Azure Blob 저장소에 있는 데이터 디스크에서 읽기보다 훨씬 빠릅니다.
2.  프리미엄 저장소는 디스크 IOPS 및 처리량으로 캐시에서 제공된 읽기를 계산하지 않습니다. 따라서 응용 프로그램은 더 높은 총 IOPS 및 처리량을 달성할 수 있습니다.

*ReadWrite* 기본적으로 OS 디스크는 ReadWrite 캐싱을 사용하도록 설정합니다. 최근에 데이터 디스크에 ReadWrite 캐싱에 대한 지원을 추가했습니다. ReadWrite 캐싱을 사용하는 경우 영구 디스크에 캐시의 데이터를 기록하는 적절한 방법이 있어야 합니다. 예를 들어 SQL Server는 자체적으로 영구 저장소 디스크에 캐시된 데이터 쓰기를 처리합니다. 필요한 데이터를 유지하도록 처리하지 않는 응용 프로그램에 ReadWrite 캐시를 사용하면 VM이 충돌할 경우 데이터 손실이 발생할 수 있습니다.

한 예로 다음을 수행하여 프리미엄 저장소에서 실행 중인 SQL Server에 이러한 지침을 적용할 수 있습니다

1.  데이터 파일을 호스팅하는 프리미엄 저장소 디스크에 "ReadOnly" 캐시를 구성합니다. a. 데이터 페이지는 데이터 디스크에서 직접 검색하는 것보다 캐시에서 훨씬 빨리 검색하므로 캐시에서 빠른 읽기는 SQL Server 쿼리 시간을 낮춥니다. b. 캐시에서 읽기 제공은 프리미엄 데이터 디스크에서 사용할 수 있는 추가 처리량이 있음을 의미합니다. SQL Server는 이 추가 처리량을 사용하여 더 많은 데이터 페이지와 백업/복원, 배치 처리 및 인덱스 다시 빌드와 같은 다른 작업을 검색할 수 있습니다.
2.  로그 파일을 호스팅하는 프리미엄 저장소 디스크에 "None" 캐시를 구성합니다. a. 로그 파일은 주로 많은 쓰기 작업을 가집니다. 따라서 ReadOnly 캐시에서 유용하지 않습니다.

## 디스크 스트라이프  
높은 확장성의 VM이 여러 프리미엄 저장소 영구 디스크와 연결되어 있는 경우 디스크는 해당 IOP, 대역폭 및 저장소 용량을 집계하도록 함께 스트라이프될 수 있습니다.

Windows에서 저장소 공간을 사용하여 디스크를 함께 스트라이프할 수 있습니다. 풀에서 각 디스크마다 하나의 열을 구성해야 합니다. 그렇지 않은 경우 디스크에서의 고르지 못한 트래픽 분배로 예상보다 스트라이프 볼륨의 전반적인 성능이 저하될 수 있습니다.

중요: 서버 관리자 UI를 사용하여 스트라이프 볼륨에 대해 최대 8개까지 열의 총 수를 설정할 수 있습니다. 8개 이상의 디스크를 연결하는 경우 PowerShell을 사용하여 볼륨을 만듭니다. PowerShell을 사용하여 디스크 수와 동일한 열 수를 설정할 수 있습니다. 예를 들어 단일 스트라이프 집합에 16개의 디스크가 있는 경우 *New-VirtualDisk* PowerShell cmdlet의 *NumberOfColumns* 매개 변수에 16개의 열을 지정합니다.


Linux에서 MDADM 유틸리티를 사용하여 디스크를 함께 스트라이프합니다. Linux에서 디스크 스트라이프에 대한 자세한 단계는 [Linux에서 소프트웨어 RAID 구성](../virtual-machines/virtual-machines-linux-configure-raid.md)을 참조하세요.


*스트라이프 크기* 디스크 스트라이프에서 중요한 구성은 스트라이프 크기입니다. 스트라이프 크기 또는 블록 크기는 응용 프로그램이 스트라이프 볼륨을 해결할 수 있는 데이터의 가장 작은 청크입니다. 구성한 스트라이프 크기는 응용 프로그램 및 해당 요청 패턴의 형식에 따라 달라집니다. 잘못된 스트라이프 크기를 선택하는 경우 응용 프로그램의 성능이 저하되는 IO 정렬 문제가 발생할 수 있습니다.

예를 들어 응용 프로그램에 의해 생성된 IO 요청이 디스크 스트라이프 크기보다 큰 경우 저장소 시스템은 둘 이상의 디스크에 스트라이프 단위 경계를 넘어 작성합니다. 해당 데이터에 액세스할 때 요청을 완료하려면 둘 이상의 스트라이프 단위 간을 검색해야 합니다. 이러한 동작의 누적 된 효과로 성능이 상당히 저하될 수 있습니다. 반면에 IO 요청 크기가 스트라이프 크기보다 작고 기본적으로 임의일 경우 IO 요청은 병목 상태가 발생하고 궁극적으로 IO 성능이 저하되는 동일한 디스크에 추가할 수 있습니다.


응용 프로그램이 실행하는 작업의 유형에 따라 적절한 스트라이프 크기를 선택합니다. 작은 임의 IO 요청의 경우 더 작은 스트라이프 크기를 사용합니다. 반면 큰 순차 IO 요청의 경우 더 큰 스트라이프 크기를 사용합니다. 프리미엄 저장소에서 실행되는 응용 프로그램에 대한 스트라이프 크기 권장 사항에 대해 알아봅니다. SQL Server의 경우 OLTP 작업에 대해 64KB의 스트라이프 크기, 데이터 웨어하우징 작업에 대해 256KB의 스트라이프 크기를 구성합니다. 자세한 내용은 [Azure VM의 SQL Server에 대한 성능 모범 사례](../virtual-machines/virtual-machines-windows-sql-performance.md#disks-and-performance-considerations)를 참조하세요.


>**참고:** DS 시리즈 VM에 최대 32개의 프리미엄 저장소 디스크를 GS 시리즈 VM에 64개의 프리미엄 저장소 디스크를 함께 스트라이프할 수 있습니다.

## 다중 스레드  
Azure는 대규모로 병렬되도록 프리미엄 저장소 플랫폼을 설계합니다. 따라서 다중 스레드 응용 프로그램은 단일 스레드 응용 프로그램에 비해 훨씬 더 높은 성능을 얻을 수 있습니다. 다중 스레드 응용 프로그램은 여러 스레드로 해당 작업을 분할하고 VM 및 디스크 리소스를 최대한으로 활용하여 해당 실행의 효율성을 높입니다.

예를 들어 응용 프로그램이 두 개의 스레드를 사용하여 단일 코어 VM에서 실행 중인 경우 CPU는 효율성을 달성하기 위해 두 스레드 사이를 전환할 수 있습니다. 한 스레드가 디스크 IO 완료를 대기하는 동안 CPU에서 다른 스레드로 전환할 수 있습니다. 이러한 방식으로 두 스레드는 단일 스레드보다 더 많은 작업을 수행할 수 있습니다. VM에 두 개 이상의 코어가 있는 경우 각 코어는 병렬로 작업을 실행할 수 있으므로 실행 시간이 더 줄어듭니다.

기존의 응용 프로그램이 단일 스레딩 또는 다중 스레딩을 구현하는 방식을 변경할 수 없을 수도 있습니다. 예를 들어 SQL Server는 다중 CPU 및 다중 코어를 처리할 수 있습니다. 그러나 SQL Server는 어떤 조건에서 쿼리를 처리하도록 하나 이상의 스레드를 활용할지를 결정합니다. 다중 스레드를 사용하여 쿼리를 실행하고 인덱스를 작성할 수 있습니다. 사용자에게 반환하기 전에 큰 테이블 결합 및 데이터 정렬을 포함하는 쿼리의 경우 SQL Server는 다중 스레드를 사용할 수 있습니다. 그러나 사용자는 SQL Server에서 단일 스레드 또는 다중 스레드를 사용하여 쿼리를 실행할지 여부를 제어할 수 없습니다.

이 다중 스레딩 또는 응용 프로그램의 병렬 처리에 영향을 주도록 변경할 수 있는 구성 설정이 있습니다. 예를 들어 SQL Server의 경우 병렬 구성의 최대 수준입니다. 이 설정은 MAXDOP로 SQL Server에서 병렬 처리 시 사용할 수는 프로세서의 최대 수를 구성할 수 있습니다. 개별 쿼리 또는 인덱스 작업에 대한 MAXDOP를 구성할 수 있습니다. 이것은 성능이 중요한 응용 프로그램에 대한 시스템의 리소스 균형을 유지하려는 경우에 유용합니다.

예를 들어 SQL Server를 사용하는 응용 프로그램이 큰 쿼리와 인덱스 작업을 동시에 실행한다고 가정합니다. 인덱스 작업이 큰 쿼리보다 성능이 높아지길 원한다고 가정해 보겠습니다. 이러한 경우 쿼리에 대한 MAXDOP 값보다 높도록 인덱스 작업의 MAXDOP 값을 설정할 수 있습니다. 이러한 방식으로 SQL Server는 더 큰 쿼리에 사용할 수는 프로세서 수에 비해 인덱스 작업에 활용할 수 있는 더 많은 프로세서 수를 가집니다. SQL Server에서 각 작업에 사용할 스레드 수를 제어하지 않습니다. 다중 스레딩에 사용되는 프로세서의 최대 수를 제어할 수 있습니다.

SQL Server에 [병렬 처리의 정도](https://technet.microsoft.com/library/ms188611.aspx)에 대한 자세한 정보가 있습니다. 성능을 최적화하도록 응용 프로그램의 다중 스레딩 및 해당 구성에 영향을 주는 설정을 확인합니다.

## 큐 크기  
큐 크기 또는 큐 길이 또는 큐 크기는 시스템에서 보류 중인 IO 요청 횟수입니다. 큐 크기의 값은 응용 프로그램이 응용 프로그램이 저장소 디스크에서 처리되는 얼마나 많은 IO 작업을 줄 세울 수 있을지 결정합니다. 이는 이 문서에서 설명한 세 가지 응용 프로그램 성능 지표인 IOPS, 처리량 및 대기 시간 모두에 영향을 줍니다.

큐 크기 및 다중 스레딩은 밀접한 관련이 있습니다. 큐 크기 값은 얼마나 많은 다중 스레딩을 응용 프로그램에서 수행할 수 있는지를 나타냅니다. 큐 크기가 클 경우 응용 프로그램은 동시에 더 많은 작업 즉 다중 스레딩을 실행할 수 있습니다. 큐 크기가 작은 경우 응용 프로그램이 다중 스레드이더라도 동시 실행에 대한 충분한 요청이 없습니다.

일반적으로 잘못 설정한 경우 해가 되므로 기존 응용 프로그램을 통해 큐 크기를 변경할 수 없습니다. 응용 프로그램은 최적의 성능을 얻기 위해 올바른 값의 큐 크기를 설정합니다. 그러나 응용 프로그램의 성능 문제를 해결할 수 있도록 이 개념을 이해하는 것이 중요합니다. 또한 시스템의 벤치마킹 도구를 실행하여 큐 크기의 효과를 확인할 수 있습니다.

일부 응용 프로그램은 큐 크기에 영향을 미칠 수 있는 설정을 제공합니다. 예를 들어 이전 섹션에서 설명한 SQL Server의 MAXDOP(최대 수준의 병렬 처리) 설정입니다. MAXDOP는 SQL Server의 큐 크기 값을 직접 변경하지는 않지만 큐 크기 및 다중 스레딩에 영향을 주는 방법입니다.

*높은 큐 크기* 높은 큐 크기는 디스크에 더 많은 작업을 정렬합니다. 디스크는 해당 큐에서 미리 다음 요청을 알고 있습니다. 따라서 디스크는 미리 작업을 예약하고 최적의 순서로 작업을 처리할 수 있습니다. 응용 프로그램이 디스크에 더 많은 요청을 보내므로 디스크는 더 많은 병렬 IO를 처리할 수 있습니다. 궁극적으로 응용 프로그램은 더 높은 IOPS를 끌어낼 수 있습니다. 응용 프로그램이 더 많은 요청을 처리하므로 응용 프로그램의 총 처리량도 증가합니다.

일반적으로 응용 프로그램에서 연결된 디스크당 8-16+ 미해결 IO로 최대 처리량을 달성할 수 있습니다. 큐 크기가 하나인 경우 응용 프로그램은 시스템에 충분한 IO를 푸시하지 않고 지정된 기간 동안 적은 양을 처리합니다. 즉, 적은 처리량입니다.

예를 들어 SQL Server에서 쿼리에 대한 MAXDOP 값을 "4"로 설정하면 SQL Server에 쿼리를 실행하는데 최대 4개의 코어를 사용할 수 있음을 알립니다. SQL Server는 쿼리 실행에 대한 최적의 큐 크기 값 및 코어 수를 결정합니다.

*최적의 큐 크기* 매우 높은 큐 크기 값 또한 단점이 있습니다. 큐 크기 값이 너무 높으면 응용 프로그램은 매우 높은 IOPS를 구동하려고 합니다. 응용 프로그램에 프로비전된 충분한 IOPS의 영구 디스크가 있지 않는 한 응용 프로그램 대기 시간이 늘어날 수 있습니다. 다음 수식은 IOPS, 대기 시간 및 큐 크기 간의 관계를 보여 줍니다. ![](media/storage-premium-storage-performance/image6.png)

큐 크기를 대기 시간에 영향을 주지 않고 응용 프로그램에 충분한 IOPS를 제공할 수 있는 최적의 값이 아닌 높은 값을 구성해서는 안됩니다. 예를 들어 응용 프로그램 대기 시간에 1밀리초가 필요한 경우 5,000개의 IOPS를 달성하기 위해 필요한 큐 크기는 QD = 5000 x 0.001 = 5입니다.

*스트라이프 볼륨에 대한 큐 크기* 그러한 충분한 큐 크기를 유지하는 스트라이프 볼륨의 경우 모든 디스크는 개별적으로 최대 큐 크기를 가집니다. 예를 들어 2의 큐 크기를 푸시하는 응용 프로그램과 스트라이프에 4개의 디스크가 있다고 가정합니다. 두 개의 IO 요청은 2개의 디스크로 이동하고 나머지 두 디스크는 유휴 상태가 됩니다. 따라서 모든 디스크가 사용 중일 수 있도록 큐 크기를 구성합니다. 다음 수식에서는 스트라이프 볼륨의 큐 크기를 결정하는 방법을 보여 줍니다. ![](media/storage-premium-storage-performance/image7.png)

## 제한  
Azure 프리미엄 저장소는 선택한 VM 크기 및 디스크 크기에 따라 지정된 IOPS 수 및 처리량을 프로비전합니다. 응용 프로그램이 VM 또는 디스크가 처리할 수 있는 한도를 초과하여 IOPS 또는 처리량을 구동하려 할 때 프리미엄 저장소는 이를 제한합니다. 이는 응용 프로그램에서 성능 저하의 형태로 나타납니다. 이는 더 높은 대기 시간, 더 낮은 처리량 또는 더 낮은 IOPS를 의미할 수 있습니다. 프리미엄 저장소가 제한하지 않는 경우 응용 프로그램은 리소스가 달성할 수 있는 한도를 초과하여 완전히 실패할 수 있습니다. 따라서 제한으로 인한 성능 문제를 방지하려면 항상 응용 프로그램에 대한 충분한 리소스를 프로비전합니다. 위의 VM 크기 및 디스크 크기 섹션에서 설명한 것을 고려합니다. 벤치마킹은 응용 프로그램을 호스팅하는데 필요한 리소스를 찾는데 가장 적합합니다.

## 벤치마킹  
벤치마킹은 응용 프로그램에서 다양한 작업을 시뮬레이션하고 각 작업에 대한 응용 프로그램 성능을 측정하는 과정입니다. 이전 섹션에서 설명한 단계를 사용하여 응용 프로그램 성능 요구 사항을 수집했습니다. 응용 프로그램을 호스팅하는 VM에서 벤치마킹 도구를 실행하여 프리미엄 저장소를 통해 응용 프로그램이 얻을 수 있는 성능 수준을 확인할 수 있습니다. 이 섹션에서는 Azure 프리미엄 저장소 디스크로 프로비전된 Standard DS14 VM 벤치마킹의 예를 제공합니다.

Windows 및 Linux용으로 각각 일반 벤치마킹 도구 Iometer 및 FIO를 사용했습니다. 이러한 도구는 작업과 같은 프로덕션을 시뮬레이션하는 여러 스레드를 생성하고 시스템 성능을 측정합니다. 도구를 사용하여 일반적으로 응용 프로그램에 대해 변경할 수 없는 블록 크기 및 큐 크기와 같은 매개 변수를 구성할 수도 있습니다. 응용 프로그램 작업의 다양한 유형에 대해 프리미엄 디스크로 프로비전된 높은 확장성의 VM에 최대 성능을 구동하도록 유연성을 제공합니다. 각 벤치마킹 도구에 대한 자세한 내용은 [Iometer](http://www.iometer.org/) 및 [FIO](http://freecode.com/projects/fio)를 방문하세요.

아래 예제를 수행하려면 Standard DS14 VM을 만들고 VM에 11개의 프리미엄 저장소 디스크를 연결합니다. 11개의 디스크는 "None"으로 호스트 캐싱을 사용하여 10개의 디스크를 구성하고 NoCacheWrites라는 볼륨으로 스트라이프합니다. 나머지 디스크에 "ReadOnly"로 호스트 캐싱을 구성하고 이 디스크를 사용하여 CacheReads라는 볼륨을 만듭니다. 이 설치를 사용하여 Standard DS14 VM에서 최대 읽기 및 쓰기 성능을 확인할 수 있습니다. 프리미엄 디스크를 사용하여 DS14 VM 만들기에 대한 자세한 단계는 [가상 컴퓨터 데이터 디스크에 대한 프리미엄 저장소 계정 만들기 및 사용](storage-premium-storage.md#create-and-use-a-premium-storage-account-for-a-virtual-machine-data-disk)으로 이동합니다.

*캐시 준비 중* ReadOnly 호스트 캐싱을 사용한 디스크는 디스크 제한보다 더 높은 IOPS를 부여할 수 있습니다. 호스트 캐시에서 이 최대 읽기 성능을 얻으려면 먼저 이 디스크의 캐시를 준비해야 합니다. 이렇게 하면 벤치마킹 도구에서 CacheReads 볼륨을 구동하는 읽기 IO는 실제로 디스크가 아닌 캐시에 도달합니다. 캐시는 단일 캐시가 사용된 디스크에서 추가 IOPS 결과에 도달합니다.

>**중요:** VM을 다시 부팅할 때마다 벤치마킹을 실행하기 전에 캐시를 준비해야 합니다.

#### Iometer   
VM에 [Iometer 도구를 다운로드](http://sourceforge.net/projects/iometer/files/iometer-stable/2006-07-27/iometer-2006.07.27.win32.i386-setup.exe/download)합니다.

*테스트 파일* Iometer는 벤치마킹 테스트를 실행할 볼륨에 저장된 테스트 파일을 사용합니다. IOPS 디스크 및 처리량을 측정하도록 이 테스트 파일에 읽기 및 쓰기를 구동합니다. Iometer는 이 테스트 파일을 제공받지 않은 경우 만듭니다. CacheReads 및 NoCacheWrites 볼륨에 iobw.tst라는 200GB 테스트 파일을 만듭니다.

*액세스 사양* 요청 IO 크기, % 읽기/쓰기, % 임의/순차 사양은 Iometer의 "액세스 사양" 탭을 사용하여 구성됩니다. 아래에 설명된 각 시나리오에 대한 액세스 사양을 만듭니다. 액세스 사양을 만들고 – RandomWrites\_8K, RandomReads\_8K와 같은 적절한 이름으로 "저장"합니다. 테스트 시나리오를 실행할 때 해당 사양을 선택합니다.

최대 쓰기 IOPS 시나리오에 대한 액세스 사양의 예는 아래와 같습니다. ![](media/storage-premium-storage-performance/image8.png)

*최대 IOPS 테스트 사양* 최대 IOP를 보여주기 위해 작은 요청 크기를 사용합니다. 8K 요청 크기를 사용하고 임의 쓰기 및 읽기에 대한 사양을 만듭니다.

| 액세스 사양 | 요청 크기 | 임의 % | 읽기 % |
|----------------------|--------------|----------|--------|
| RandomWrites\_8K | 8K | 100 | 0 |
| RandomReads\_8K | 8K | 100 | 100 |

*최대 처리량 테스트 사양* 최대 처리량을 보여주기 위해 더 큰 요청 크기를 사용합니다. 64K 요청 크기를 사용하여 임의 쓰기 및 읽기에 대한 사양을 만듭니다.

| 액세스 사양 | 요청 크기 | 임의 % | 읽기 % |
|----------------------|--------------|----------|--------|
| RandomWrites\_64K | 64K | 100 | 0 |
| RandomReads\_64K | 64K | 100 | 100 |

*Iometer 테스트 실행* 아래 단계를 수행하여 캐시를 준비합니다.

1.  아래에 표시된 값으로 두 액세스 사양을 만듭니다.

	| 이름 | 요청 크기 | 임의 % | 읽기 % |
	|-------------------|--------------|----------|--------|
	| RandomWrites\_1MB | 1MB | 100 | 0 |
	| RandomReads\_1MB | 1MB | 100 | 100 |

2.  다음 매개 변수로 캐시 디스크 초기화를 위한 Iometer 테스트를 실행합니다. 대상 볼륨에 대해 3개의 작업자 스레드 및 128의 큐 크기를 사용합니다. 테스트의 "실행 시간" 기간을 "테스트 설정" 탭에서 2hrs로 설정합니다.

	| 시나리오 | 대상 볼륨 | 이름 | 기간 |
	|-----------------------|---------------|-------------------|----------|
	| 디스크 캐시 초기화 | CacheReads | RandomWrites\_1MB | 2hrs |

3.  다음 매개 변수로 캐시 디스크 준비를 위한 Iometer 테스트를 실행합니다. 대상 볼륨에 대해 3개의 작업자 스레드 및 128의 큐 크기를 사용합니다. 테스트의 "실행 시간" 기간을 "테스트 설정" 탭에서 2hrs로 설정합니다.

	| 시나리오 | 대상 볼륨 | 이름 | 기간 |
	|--------------------|---------------|------------------|----------|
	| 캐시 디스크 준비 | CacheReads | RandomReads\_1MB | 2hrs |

캐시 디스크를 준비한 후 아래에 나열된 테스트 시나리오를 계속합니다. Iometer 테스트를 실행하려면 **각** 대상 볼륨에 대해 최소 세 개의 작업자 스레드를 사용합니다. 각 작업자 스레드의 경우 해당 테스트 시나리오를 실행하도록 아래 표에 표시된 것처럼 대상 볼륨을 선택하고 큐 크기를 설정하고 저장된 테스트 사양 중 하나를 선택합니다. 또한 표는 이러한 테스트를 실행할 때 IOPS 및 처리량에 대한 예상된 결과를 보여 줍니다. 모든 시나리오의 경우 8KB의 작은 IO 크기 및 128의 높은 큐 크기가 사용됩니다.

| 테스트 시나리오 | 대상 볼륨 | 이름 | 결과 |
|--------------------|---------------|-------------------|--------------|
| 최대 읽기 IOPS | CacheReads | RandomWrites\_8K | 50,000 IOPS |
| 최대 쓰기 IOPS | NoCacheWrites | RandomReads\_8K | 64,000 IOPS |
| 최대 결합된 IOPS | CacheReads | RandomWrites\_8K | 100,000 IOPS |
| | NoCacheWrites | RandomReads\_8K | |
| 최대 읽기 MB/초 | CacheReads | RandomWrites\_64K | 524MB/초 |
| 최대 쓰기 MB/초 | NoCacheWrites | RandomReads\_64K | 524MB/초 |
| 결합된 MB/초 | CacheReads | RandomWrites\_64K | 1000MB/초 |
| | NoCacheWrites | RandomReads\_64K | |

아래는 결합된 IOPS 및 처리량 시나리오에 대한 Iometer 테스트 결과의 스크린샷입니다.

*읽기 및 쓰기 최대 IOPS를 결합* ![](media/storage-premium-storage-performance/image9.png)

*읽기 및 쓰기 최대 처리량을 결합* ![](media/storage-premium-storage-performance/image10.png)

### FIO  
FIO는 Linux VM의 벤치마크 저장소에 널리 사용되는 도구입니다. 다른 IO 크기, 순차 또는 임의 읽기 및 쓰기를 선택하는 유연성을 가집니다. 지정된 I/O 작업을 수행하는 작업자 스레드 또는 프로세스를 생성합니다. 각 작업자 스레드가 작업 파일을 사용하여 수행해야 하는 I/O 작업의 유형을 지정할 수 있습니다. 아래 예에 나와 있는 시나리오 당 하나의 작업 파일을 만들었습니다. 프리미엄 저장소에서 실행되는 다른 작업을 벤치마크하도록 이러한 작업 파일의 사양을 변경할 수 있습니다. 예제에서 **Ubuntu**를 실행하는 Standard DS 14 VM을 사용하고 있습니다. [벤치마킹 섹션](#Benchmarking)의 시작 부분에서 설명한 동일한 설치를 사용하고 벤치마킹 테스트를 실행하기 전에 캐시를 준비합니다.

시작하기 전에 [FIO를 다운로드](https://github.com/axboe/fio)하고 가상 컴퓨터에 설치합니다.

Ubuntu에 대해 다음 명령을 실행합니다.

		apt-get install fio

디스크에서 쓰기 작업 구동에 대해 4개의 작업자 스레드를 읽기 작업 구동에 대해 4개의 작업자 스레드를 사용합니다. 쓰기 작업자는 "None"으로 설정된 캐시와 10개의 디스크가 있는 "nocache" 볼륨의 트래픽으로 구동됩니다. 쓰기 작업자는 "ReadOnly"로 설정된 캐시와 1개의 디스크가 있는 "readcache" 볼륨의 트래픽으로 구동됩니다.

*최대 쓰기 IOPS* 최대 쓰기 IOPS를 얻으려면 다음 사양을 가진 작업 파일을 만듭니다. “fiowrite.ini”로 이름을 지정합니다.

```
[global]
size=30g
direct=1
iodepth=256
ioengine=libaio
bs=8k

[writer1]
rw=randwrite
directory=/mnt/nocache
[writer2]
rw=randwrite
directory=/mnt/nocache
[writer3]
rw=randwrite
directory=/mnt/nocache
[writer4]
rw=randwrite
directory=/mnt/nocache
```

이전 섹션에서 설명한 설계 지침을 따라 핵심 사항을 기록해 둡니다. 이러한 사양은 최대 IOPS 구동에 필수적입니다.
-   256의 높은 큐 크기.
-   8KB의 작은 블록 크기.
-   임의 쓰기를 수행하는 다중 스레드.

다음 명령을 실행하여 30초 동안 FIO 테스트를 시작합니다.

	sudo fio --runtime 30 fiowrite.ini

테스트가 실행되는 동안 VM 및 프리미엄 디스크가 제공하는 쓰기 IOPS 수를 볼 수 있습니다. 아래 예제처럼 DS14 VM은 50,000 IOPS의 해당 최대 쓰기 IOPS 제한을 제공합니다. ![](media/storage-premium-storage-performance/image11.png)

*최대 읽기 IOPS* 최대 읽기 IOPS를 얻으려면 다음 사양을 가진 작업 파일을 만듭니다. "fioread.ini"로 이름을 지정합니다.

```
[global]
size=30g
direct=1
iodepth=256
ioengine=libaio
bs=8k

[reader1]
rw=randread
directory=/mnt/readcache
[reader2]
rw=randread
directory=/mnt/readcache
[reader3]
rw=randread
directory=/mnt/readcache
[reader4]
rw=randread
directory=/mnt/readcache
```

이전 섹션에서 설명한 설계 지침을 따라 핵심 사항을 기록해 둡니다. 이러한 사양은 최대 IOPS 구동에 필수적입니다.

-   256의 높은 큐 크기.
-   8KB의 작은 블록 크기.
-   임의 쓰기를 수행하는 다중 스레드.

다음 명령을 실행하여 30초 동안 FIO 테스트를 시작합니다.

	sudo fio --runtime 30 fioread.ini

테스트가 실행되는 동안 VM 및 프리미엄 디스크가 제공하는 읽기 IOPS 수를 볼 수 있습니다. 아래 예제처럼 DS14 VM은 64,000 읽기 IOPS보다 많이 제공합니다. 이는 디스크와 캐시 성능의 조합입니다. ![](media/storage-premium-storage-performance/image12.png)

*최대 읽기 및 쓰기 IOPS* 결합된 최대 읽기 및 쓰기 IOPS를 얻으려면 다음과 같은 사양의 작업 파일을 만듭니다. "fioreadwrite.ini"로 이름을 지정합니다.

```
[global]
size=30g
direct=1
iodepth=128
ioengine=libaio
bs=4k

[reader1]
rw=randread
directory=/mnt/readcache
[reader2]
rw=randread
directory=/mnt/readcache
[reader3]
rw=randread
directory=/mnt/readcache
[reader4]
rw=randread
directory=/mnt/readcache

[writer1]
rw=randwrite
directory=/mnt/nocache
rate_iops=12500
[writer2]
rw=randwrite
directory=/mnt/nocache
rate_iops=12500
[writer3]
rw=randwrite
directory=/mnt/nocache
rate_iops=12500
[writer4]
rw=randwrite
directory=/mnt/nocache
rate_iops=12500
```

이전 섹션에서 설명한 설계 지침을 따라 핵심 사항을 기록해 둡니다. 이러한 사양은 최대 IOPS 구동에 필수적입니다.

-   128의 높은 큐 크기
-   4KB의 작은 블록 크기
-   임의 읽기 및 쓰기를 수행하는 다중 스레드

다음 명령을 실행하여 30초 동안 FIO 테스트를 시작합니다.

	sudo fio --runtime 30 fioreadwrite.ini

테스트가 실행되는 동안 VM 및 프리미엄 디스크가 제공하는 결합된 읽기 및 쓰기 IOPS 수를 볼 수 있습니다. 아래 예제처럼 DS14 VM은 결합된 읽기 및 쓰기 IOPS를 100,000 보다 많이 제공합니다. 이는 디스크와 캐시 성능의 조합입니다. ![](media/storage-premium-storage-performance/image13.png)

*결합된 최대 처리량* 결합된 최대 읽기 및 쓰기 처리량을 얻으려면 읽기 및 쓰기를 수행하는 다중 스레드로 더 큰 블록 크기 및 큰 큐 크기를 사용합니다. 64KB의 블록 크기와 128의 큐 크기를 사용할 수 있습니다.

## 다음 단계  

Azure 프리미엄 저장소에 대한 자세한 정보

- [프리미엄 저장소: Azure 가상 컴퓨터 워크로드를 위한 고성능 저장소](storage-premium-storage.md)

SQL Server 사용자의 경우 SQL Server에 대한 성능 모범 사례의 문서를 읽으세요.

- [Azure 가상 컴퓨터의 SQL Server에 대한 성능 모범 사례](../virtual-machines/virtual-machines-windows-sql-performance.md)
- [Azure 프리미엄 저장소는 Azure VM의 SQL Server에 대해 가장 높은 성능을 제공합니다](http://blogs.technet.com/b/dataplatforminsider/archive/2015/04/23/azure-premium-storage-provides-highest-performance-for-sql-server-in-azure-vm.aspx)

<!---HONumber=AcomDC_0921_2016-->